const j=function(){const e=$,E=_,c=this,u="parser.js: Parser(): ",S=function(){this.state=e.ACTIVE,this.phraseLength=0,this.refresh=()=>{this.state=e.ACTIVE,this.phraseLength=0}};c.ast=void 0,c.stats=void 0,c.trace=void 0,c.callbacks=[];let s=0,p=0,M=0,w=0,C=0,d,k,a,i,t=new S,n,o,g;const N=()=>{s=0,p=0,M=0,w=0,C=0,d=void 0,k=void 0,a=void 0,i=void 0,t.refresh(),n=void 0,o=void 0,g=void 0},m=()=>{const l=`${u}initializeCallbacks(): `;let r;for(n=[],o=[],r=0;r<d.length;r+=1)n[r]=void 0;for(r=0;r<k.length;r+=1)o[r]=void 0;let h;const T=[];for(r=0;r<d.length;r+=1)T.push(d[r].lower);for(r=0;r<k.length;r+=1)T.push(k[r].lower);for(const f in c.callbacks)if(c.callbacks.hasOwnProperty(f)){if(r=T.indexOf(f.toLowerCase()),r<0)throw new Error(`${l}syntax callback '${f}' not a rule or udt name`);if(h=c.callbacks[f]?c.callbacks[f]:void 0,typeof h=="function"||h===void 0)r<d.length?n[r]=h:o[r-d.length]=h;else throw new Error(`${l}syntax callback[${f}] must be function reference or falsy)`)}};c.parse=(l,r,h,T)=>{const f=`${u}parse(): `;N(),i=E.stringToChars(h),d=l.rules,k=l.udts;const A=r.toLowerCase();let L;for(const Y in d)if(d.hasOwnProperty(Y)&&A===d[Y].lower){L=d[Y].index;break}if(L===void 0)throw new Error(`${f}start rule name '${startRule}' not recognized`);m(),c.trace&&c.trace.init(d,k,i),c.stats&&c.stats.init(d,k),c.ast&&c.ast.init(d,k,i),g=T,a=[{type:e.RNM,index:L}],O(0,0),a=void 0;let b=!1;switch(t.state){case e.ACTIVE:throw new Error(`${f}final state should never be 'ACTIVE'`);case e.NOMATCH:b=!1;break;case e.EMPTY:case e.MATCH:t.phraseLength===i.length?b=!0:b=!1;break;default:throw new Error("unrecognized state")}return{success:b,state:t.state,stateName:e.idName(t.state),length:i.length,matched:t.phraseLength,maxMatched:C,maxTreeDepth:M,nodeHits:w}};const P=(l,r)=>{const h=a[l];for(let T=0;T<h.children.length&&(O(h.children[T],r),t.state===e.NOMATCH);T+=1);},H=(l,r)=>{let h,T,f,A;const L=a[l];c.ast&&(T=c.ast.getLength()),h=!0,f=r,A=0;for(let b=0;b<L.children.length;b+=1)if(O(L.children[b],f),t.state===e.NOMATCH){h=!1;break}else f+=t.phraseLength,A+=t.phraseLength;h?(t.state=A===0?e.EMPTY:e.MATCH,t.phraseLength=A):(t.state=e.NOMATCH,t.phraseLength=0,c.ast&&c.ast.setLength(T))},D=(l,r)=>{let h,T,f,A;const L=a[l];if(L.max===0){t.state=e.EMPTY,t.phraseLength=0;return}for(T=r,f=0,A=0,c.ast&&(h=c.ast.getLength());!(T>=i.length||(O(l+1,T),t.state===e.NOMATCH)||t.state===e.EMPTY||(A+=1,f+=t.phraseLength,T+=t.phraseLength,A===L.max)););t.state===e.EMPTY||A>=L.min?(t.state=f===0?e.EMPTY:e.MATCH,t.phraseLength=f):(t.state=e.NOMATCH,t.phraseLength=0,c.ast&&c.ast.setLength(h))},U=(l,r,h,T)=>{if(r.phraseLength>h){let f=`${u}opRNM(${l.name}): callback function error: `;throw f+=`sysData.phraseLength: ${r.phraseLength}`,f+=` must be <= remaining chars: ${h}`,new Error(f)}switch(r.state){case e.ACTIVE:if(!T)throw new Error(`${u}opRNM(${l.name}): callback function return error. ACTIVE state not allowed.`);break;case e.EMPTY:r.phraseLength=0;break;case e.MATCH:r.phraseLength===0&&(r.state=e.EMPTY);break;case e.NOMATCH:r.phraseLength=0;break;default:throw new Error(`${u}opRNM(${l.name}): callback function return error. Unrecognized return state: ${r.state}`)}},y=(l,r)=>{let h,T,f;const A=a[l],L=d[A.index],b=n[L.index];if(s||(T=c.ast&&c.ast.ruleDefined(A.index),T&&(h=c.ast.getLength(),c.ast.down(A.index,d[A.index].name))),b){const Y=i.length-r;b(t,i,r,g),U(L,t,Y,!0),t.state===e.ACTIVE&&(f=a,a=L.opcodes,O(0,r),a=f,b(t,i,r,g),U(L,t,Y,!1))}else f=a,a=L.opcodes,O(0,r),a=f;s||T&&(t.state===e.NOMATCH?c.ast.setLength(h):c.ast.up(A.index,L.name,r,t.phraseLength))},x=(l,r)=>{const h=a[l];t.state=e.NOMATCH,r<i.length&&h.min<=i[r]&&i[r]<=h.max&&(t.state=e.MATCH,t.phraseLength=1)},B=(l,r)=>{const h=a[l],T=h.string.length;if(t.state=e.NOMATCH,r+T<=i.length){for(let f=0;f<T;f+=1)if(i[r+f]!==h.string[f])return;t.state=e.MATCH,t.phraseLength=T}},G=(l,r)=>{let h;const T=a[l];t.state=e.NOMATCH;const f=T.string.length;if(f===0){t.state=e.EMPTY;return}if(r+f<=i.length){for(let A=0;A<f;A+=1)if(h=i[r+A],h>=65&&h<=90&&(h+=32),h!==T.string[A])return;t.state=e.MATCH,t.phraseLength=f}},V=(l,r,h)=>{if(r.phraseLength>h){let T=`${u}opUDT(${l.name}): callback function error: `;throw T+=`sysData.phraseLength: ${r.phraseLength}`,T+=` must be <= remaining chars: ${h}`,new Error(T)}switch(r.state){case e.ACTIVE:throw new Error(`${u}opUDT(${l.name}) ACTIVE state return not allowed.`);case e.EMPTY:if(l.empty)r.phraseLength=0;else throw new Error(`${u}opUDT(${l.name}) may not return EMPTY.`);break;case e.MATCH:if(r.phraseLength===0)if(l.empty)r.state=e.EMPTY;else throw new Error(`${u}opUDT(${l.name}) may not return EMPTY.`);break;case e.NOMATCH:r.phraseLength=0;break;default:throw new Error(`${u}opUDT(${l.name}): callback function return error. Unrecognized return state: ${r.state}`)}},z=(l,r)=>{let h,T,f;const A=a[l],L=k[A.index];t.UdtIndex=L.index,s||(f=c.ast&&c.ast.udtDefined(A.index),f&&(T=d.length+A.index,h=c.ast.getLength(),c.ast.down(T,L.name)));const b=i.length-r;o[A.index](t,i,r,g),V(L,t,b),s||f&&(t.state===e.NOMATCH?c.ast.setLength(h):c.ast.up(T,L.name,r,t.phraseLength))},v=(l,r)=>{switch(s+=1,O(l+1,r),s-=1,t.phraseLength=0,t.state){case e.EMPTY:t.state=e.EMPTY;break;case e.MATCH:t.state=e.EMPTY;break;case e.NOMATCH:t.state=e.NOMATCH;break;default:throw new Error(`opAND: invalid state ${t.state}`)}},F=(l,r)=>{switch(s+=1,O(l+1,r),s-=1,t.phraseLength=0,t.state){case e.EMPTY:case e.MATCH:t.state=e.NOMATCH;break;case e.NOMATCH:t.state=e.EMPTY;break;default:throw new Error(`opNOT: invalid state ${t.state}`)}},O=(l,r)=>{const h=`${u}opExecute(): `,T=a[l];switch(w+=1,p>M&&(M=p),p+=1,t.refresh(),c.trace&&c.trace.down(T,r),T.type){case e.ALT:P(l,r);break;case e.CAT:H(l,r);break;case e.REP:D(l,r);break;case e.RNM:y(l,r);break;case e.TRG:x(l,r);break;case e.TBS:B(l,r);break;case e.TLS:G(l,r);break;case e.UDT:z(l,r);break;case e.AND:v(l,r);break;case e.NOT:F(l,r);break;default:throw new Error(`${h}unrecognized operator`)}s||r+t.phraseLength>C&&(C=r+t.phraseLength),c.stats&&c.stats.collect(T,t),c.trace&&c.trace.up(T,t.state,r,t.phraseLength),p-=1}},K=function(){const e="parser.js: Ast()): ",E=$,c=_,u=this;let S,s,p,M=0;const w=[],C=[],d=[];u.callbacks=[],u.init=(a,i,t)=>{C.length=0,d.length=0,M=0,S=a,s=i,p=t;let n;const o=[];for(n=0;n<S.length;n+=1)o.push(S[n].lower);for(n=0;n<s.length;n+=1)o.push(s[n].lower);for(M=S.length+s.length,n=0;n<M;n+=1)w[n]=void 0;for(const g in u.callbacks)if(u.callbacks.hasOwnProperty(g)){const N=g.toLowerCase();if(n=o.indexOf(N),n<0)throw new Error(`${e}init: node '${g}' not a rule or udt name`);w[n]=u.callbacks[g]}},u.ruleDefined=a=>!!w[a],u.udtDefined=a=>!!w[S.length+a],u.down=(a,i)=>{const t=d.length;return C.push(t),d.push({name:i,thisIndex:t,thatIndex:void 0,state:E.SEM_PRE,callbackIndex:a,phraseIndex:void 0,phraseLength:void 0,stack:C.length}),t},u.up=(a,i,t,n)=>{const o=d.length,g=C.pop();return d.push({name:i,thisIndex:o,thatIndex:g,state:E.SEM_POST,callbackIndex:a,phraseIndex:t,phraseLength:n,stack:C.length}),d[g].thatIndex=o,d[g].phraseIndex=t,d[g].phraseLength=n,o},u.translate=a=>{let i,t;for(let n=0;n<d.length;n+=1)t=d[n],i=w[t.callbackIndex],i&&(t.state===E.SEM_PRE?i(E.SEM_PRE,p,t.phraseIndex,t.phraseLength,a):i&&i(E.SEM_POST,p,t.phraseIndex,t.phraseLength,a))},u.setLength=a=>{d.length=a,a>0?C.length=d[a-1].stack:C.length=0},u.getLength=()=>d.length;function k(a){let i="";for(;a-- >0;)i+=" ";return i}u.toXml=()=>{let a="",i=0;return a+=`<?xml version="1.0" encoding="utf-8"?>
`,a+=`<root nodes="${d.length/2}" characters="${p.length}">
`,a+=`<!-- input string -->
`,a+=k(i+2),a+=c.charsToString(p),a+=`
`,d.forEach(t=>{t.state===E.SEM_PRE?(i+=1,a+=k(i),a+=`<node name="${t.name}" index="${t.phraseIndex}" length="${t.phraseLength}">
`,a+=k(i+2),a+=c.charsToString(p,t.phraseIndex,t.phraseLength),a+=`
`):(a+=k(i),a+=`</node><!-- name="${t.name}" -->
`,i-=1)}),a+=`</root>
`,a}},X=function(){const e=$,E=_,c="parser.js: Trace(): ";let u,S,s,p="",M=0;const w=100,C=this,d=a=>{let i="",t=0;if(a>=0)for(;a--;)t+=1,t===5?(i+="|",t=0):i+=".";return i};C.init=(a,i,t)=>{S=a,s=i,u=t};const k=a=>{let i;switch(a.type){case e.ALT:i="ALT";break;case e.CAT:i="CAT";break;case e.REP:a.max===1/0?i=`REP(${a.min},inf)`:i=`REP(${a.min},${a.max})`;break;case e.RNM:i=`RNM(${S[a.index].name})`;break;case e.TRG:i=`TRG(${a.min},${a.max})`;break;case e.TBS:a.string.length>6?i=`TBS(${E.charsToString(a.string,0,3)}...)`:i=`TBS(${E.charsToString(a.string,0,6)})`;break;case e.TLS:a.string.length>6?i=`TLS(${E.charsToString(a.string,0,3)}...)`:i=`TLS(${E.charsToString(a.string,0,6)})`;break;case e.UDT:i=`UDT(${s[a.index].name})`;break;case e.AND:i="AND";break;case e.NOT:i="NOT";break;default:throw new Error(`${c}Trace: opName: unrecognized opcode`)}return i};C.down=(a,i)=>{const t=d(M),n=Math.min(w,u.length-i);let o=E.charsToString(u,i,n);n<u.length-i&&(o+="..."),o=`${t}|-|[${k(a)}]${o}
`,p+=o,M+=1},C.up=(a,i,t,n)=>{const o=`${c}trace.up: `;M-=1;const g=d(M);let N,m,P;switch(i){case e.EMPTY:P="|E|",m="''";break;case e.MATCH:P="|M|",N=Math.min(w,n),N<n?m=`'${E.charsToString(u,t,N)}...'`:m=`'${E.charsToString(u,t,N)}'`;break;case e.NOMATCH:P="|N|",m="";break;default:throw new Error(`${o} unrecognized state`)}m=`${g}${P}[${k(a)}]${m}
`,p+=m},C.displayTrace=()=>p},Z=function(){const e=$,E="parser.js: Stats(): ";let c,u,S;const s=[],p=[],M=[];this.init=(n,o)=>{c=n,u=o,i()},this.collect=(n,o)=>{t(S,o.state,o.phraseLength),t(s[n.type],o.state,o.phraseLength),n.type===e.RNM&&t(p[n.index],o.state,o.phraseLength),n.type===e.UDT&&t(M[n.index],o.state,o.phraseLength)},this.displayStats=()=>{let n="";const o={match:0,empty:0,nomatch:0,total:0},g=(N,m,P,H,D)=>{o.match+=m,o.empty+=P,o.nomatch+=H,o.total+=D;const U=w(m),y=w(P),x=w(H),B=w(D);return`${N} | ${U} | ${y} | ${x} | ${B} |
`};return n+=`          OPERATOR STATS
`,n+=`      |   MATCH |   EMPTY | NOMATCH |   TOTAL |
`,n+=g("  ALT",s[e.ALT].match,s[e.ALT].empty,s[e.ALT].nomatch,s[e.ALT].total),n+=g("  CAT",s[e.CAT].match,s[e.CAT].empty,s[e.CAT].nomatch,s[e.CAT].total),n+=g("  REP",s[e.REP].match,s[e.REP].empty,s[e.REP].nomatch,s[e.REP].total),n+=g("  RNM",s[e.RNM].match,s[e.RNM].empty,s[e.RNM].nomatch,s[e.RNM].total),n+=g("  TRG",s[e.TRG].match,s[e.TRG].empty,s[e.TRG].nomatch,s[e.TRG].total),n+=g("  TBS",s[e.TBS].match,s[e.TBS].empty,s[e.TBS].nomatch,s[e.TBS].total),n+=g("  TLS",s[e.TLS].match,s[e.TLS].empty,s[e.TLS].nomatch,s[e.TLS].total),n+=g("  UDT",s[e.UDT].match,s[e.UDT].empty,s[e.UDT].nomatch,s[e.UDT].total),n+=g("  AND",s[e.AND].match,s[e.AND].empty,s[e.AND].nomatch,s[e.AND].total),n+=g("  NOT",s[e.NOT].match,s[e.NOT].empty,s[e.NOT].nomatch,s[e.NOT].total),n+=g("TOTAL",o.match,o.empty,o.nomatch,o.total),n},this.displayHits=n=>{let o="";const g=(N,m,P,H,D)=>{S.match+=N,S.empty+=m,S.nomatch+=P,S.total+=H;const U=w(N),y=w(m),x=w(P),B=w(H);return`| ${U} | ${y} | ${x} | ${B} | ${D}
`};typeof n=="string"&&n.toLowerCase()[0]==="a"?(p.sort(C),M.sort(C),o+=`    RULES/UDTS ALPHABETICALLY
`):typeof n=="string"&&n.toLowerCase()[0]==="i"?(p.sort(k),M.sort(k),o+=`    RULES/UDTS BY INDEX
`):(p.sort(d),M.sort(d),o+=`    RULES/UDTS BY HIT COUNT
`),o+=`|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME
`;for(let N=0;N<p.length;N+=1){let m=p[N];m.total&&(o+=g(m.match,m.empty,m.nomatch,m.total,m.name))}for(let N=0;N<M.length;N+=1){let m=M[N];m.total&&(o+=g(m.match,m.empty,m.nomatch,m.total,m.name))}return o};const w=n=>n<10?`      ${n}`:n<100?`     ${n}`:n<1e3?`    ${n}`:n<1e4?`   ${n}`:n<1e5?`  ${n}`:n<1e6?` ${n}`:`${n}`,C=(n,o)=>n.lower<o.lower?-1:n.lower>o.lower?1:0,d=(n,o)=>n.total<o.total?1:n.total>o.total?-1:C(n,o),k=(n,o)=>n.index<o.index?-1:n.index>o.index?1:0,a=function(){this.empty=0,this.match=0,this.nomatch=0,this.total=0},i=()=>{s.length=0,S=new a,s[e.ALT]=new a,s[e.CAT]=new a,s[e.REP]=new a,s[e.RNM]=new a,s[e.TRG]=new a,s[e.TBS]=new a,s[e.TLS]=new a,s[e.UDT]=new a,s[e.AND]=new a,s[e.NOT]=new a,p.length=0;for(let n=0;n<c.length;n+=1)p.push({empty:0,match:0,nomatch:0,total:0,name:c[n].name,lower:c[n].lower,index:c[n].index});if(u.length>0){M.length=0;for(let n=0;n<u.length;n+=1)M.push({empty:0,match:0,nomatch:0,total:0,name:u[n].name,lower:u[n].lower,index:u[n].index})}},t=(n,o)=>{switch(n.total+=1,o){case e.EMPTY:n.empty+=1;break;case e.MATCH:n.match+=1;break;case e.NOMATCH:n.nomatch+=1;break;default:throw new Error(`${E}collect(): incStat(): unrecognized state: ${o}`)}}},_={stringToChars:R=>[...R].map(e=>e.codePointAt(0)),charsToString:(R,e,E)=>{let c=R;for(;!(e===void 0||e<0);){if(E===void 0){c=R.slice(e);break}if(E<=0)return"";c=R.slice(e,e+E);break}return String.fromCodePoint(...c)}},$={ALT:1,CAT:2,REP:3,RNM:4,TRG:5,TBS:6,TLS:7,UDT:11,AND:12,NOT:13,ACTIVE:100,MATCH:101,EMPTY:102,NOMATCH:103,SEM_PRE:200,SEM_POST:201,SEM_OK:300,idName:R=>{switch(R){case $.ALT:return"ALT";case $.CAT:return"CAT";case $.REP:return"REP";case $.RNM:return"RNM";case $.TRG:return"TRG";case $.TBS:return"TBS";case $.TLS:return"TLS";case $.UDT:return"UDT";case $.AND:return"AND";case $.NOT:return"NOT";case $.ACTIVE:return"ACTIVE";case $.EMPTY:return"EMPTY";case $.MATCH:return"MATCH";case $.NOMATCH:return"NOMATCH";case $.SEM_PRE:return"SEM_PRE";case $.SEM_POST:return"SEM_POST";case $.SEM_OK:return"SEM_OK";default:return"UNRECOGNIZED STATE"}}};export{K as A,j as P,Z as S,X as T,$ as i,_ as u};
